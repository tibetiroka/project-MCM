package dartproductions.mcleodmassacre.hitbox;

import dartproductions.mcleodmassacre.Main;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.imageio.ImageIO;
import java.awt.Color;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Shape implementation that is created from an image.
 *
 * @since 0.1.0
 */
public class ImageHitbox implements Shape {
	/**
	 * The created hitboxes. The key is a hash generated by {@link #calculateHash(BufferedImage)}, and the value is the hitbox of the image.
	 *
	 * @since 0.1.0
	 */
	protected static final @NotNull ConcurrentHashMap<Integer, ImageHitbox> HITBOXES = new ConcurrentHashMap<>();
	/**
	 * List of hitboxes (image hashes) that are being created; only exists because some weird concurrency issues were popping up and that seems to have fixed them
	 *
	 * @since 0.1.0
	 */
	protected static final @NotNull Set<Integer> HITBOXES_IN_PROGRESS = Collections.synchronizedSet(new HashSet<>());
	/**
	 * The runnables that are ran when a hitbox is created; only exists because some weird concurrency issues were popping up and that seems to have fixed them
	 *
	 * @since 0.1.0
	 */
	protected static final @NotNull ConcurrentHashMap<Integer, ArrayList<HitboxCreatedRunnable>> RUNNABLES = new ConcurrentHashMap<>();
	/**
	 * The amount of hitboxes being created at the moment
	 *
	 * @since 0.1.0
	 */
	protected static final @NotNull AtomicInteger PROCESSING_COUNT = new AtomicInteger();
	private static final @NotNull Logger LOGGER = LogManager.getLogger(ImageHitbox.class);
	/**
	 * The actual hitbox
	 *
	 * @since 0.1.0
	 */
	protected final @NotNull Area hitbox;
	
	/**
	 * Creates a new image hitbox. Uses the current thread for calculations, which might cause serious blocks for high-resolution images.
	 *
	 * @param image    The image to create the hitbox from
	 * @param hash     The hash of the image
	 * @param whenDone The runnable to run when the hitbox is created
	 * @since 0.1.0
	 */
	protected ImageHitbox(final @NotNull BufferedImage image, final int hash, final @Nullable HitboxCreatedRunnable whenDone) {
		hitbox = createOutline(Color.BLACK, image);
		synchronized(HITBOXES) {
			synchronized(RUNNABLES) {
				ArrayList<HitboxCreatedRunnable> a = RUNNABLES.remove(hash);
				if(a != null) {
					a.forEach(r -> {
						if(r != null) {
							r.whenFinished(this);
						}
					});
				}
				if(whenDone != null) {
					whenDone.whenFinished(this);
				}
			}
			HITBOXES.put(hash, this);
			HITBOXES_IN_PROGRESS.remove(hash);
		}
		LOGGER.debug("Created image hitbox " + hash);
		//
		//
		synchronized(PROCESSING_COUNT) {
			if(PROCESSING_COUNT.decrementAndGet() == 0) {
				PROCESSING_COUNT.notifyAll();
			}
		}
	}
	
	/**
	 * Gets an existing image hitbox that represents the given image.
	 *
	 * @param image The image to check
	 * @return The hitbox or null if it is not created yet
	 * @since 0.1.0
	 */
	public static @Nullable ImageHitbox getFromImage(final @NotNull BufferedImage image) {
		try {
			int hash = calculateHash(image);
			return HITBOXES.get(hash);
		} catch(Exception e) {
			LOGGER.error("Could not calculate MD5 checksum of image", e);
			return null;
		}
	}
	
	/**
	 * Creates a new hitbox from the image.
	 *
	 * @param image The image to use
	 * @since 0.1.0
	 */
	public static void createFromImage(final @NotNull BufferedImage image) {
		createFromImage(image, null);
	}
	
	/**
	 * Creates a new hitbox from the image.
	 *
	 * @param image    The image to use
	 * @param whenDone The action to run when the hitbox is created
	 * @since 0.1.0
	 */
	public static void createFromImage(final @NotNull BufferedImage image, final @Nullable HitboxCreatedRunnable whenDone) {
		Main.getExecutors().execute(() -> {
			try {
				int hash = calculateHash(image);
				synchronized(HITBOXES) {//okay fuck that, give me edge cases NOW
					synchronized(RUNNABLES) {
						if(!HITBOXES.containsKey(hash) && !HITBOXES_IN_PROGRESS.contains(hash)) {
							PROCESSING_COUNT.incrementAndGet();
							HITBOXES_IN_PROGRESS.add(hash);
							Main.getExecutors().execute(() -> new ImageHitbox(image, hash, whenDone));
						} else {
							if(HITBOXES.containsKey(hash)) {
								if(whenDone != null) {
									whenDone.whenFinished(HITBOXES.get(hash));
								}
							} else {
								ArrayList<HitboxCreatedRunnable> a = RUNNABLES.getOrDefault(hash, new ArrayList<>());
								a.add(whenDone);
								RUNNABLES.put(hash, a);
							}
						}
					}
				}
			} catch(Exception e) {
				LOGGER.error("Could not calculate MD5 checksum of image", e);
			}
		});
	}
	
	/**
	 * Calculates a hash based on the given image.
	 *
	 * @param image The image to use
	 * @return The hash
	 * @throws IOException              If an exception occurs
	 * @throws NoSuchAlgorithmException If an exception occurs
	 * @since 0.1.0
	 */
	private static int calculateHash(@NotNull BufferedImage image) throws IOException, NoSuchAlgorithmException {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		ImageIO.write(image, "png", outputStream);
		byte[] data = outputStream.toByteArray();
		MessageDigest md = MessageDigest.getInstance("MD5");
		md.update(data);
		byte[] hash = md.digest();
		return Arrays.hashCode(hash);
	}
	
	/**
	 * Waits until all created hitboxes have been processed. Also waits for hitboxes that are created during the wait, but doesn't stop creating new hitboxes after the wait.
	 *
	 * @since 0.1.0
	 */
	public static void waitForProcessing() {
		synchronized(PROCESSING_COUNT) {
			if(PROCESSING_COUNT.get() > 0) {
				try {
					PROCESSING_COUNT.wait();
				} catch(InterruptedException e) {
					LOGGER.warn("Wait for hitbox processing was interrupted", e);
				}
			}
		}
	}
	
	/**
	 * Gets the hitbox area of this hitbox.
	 *
	 * @return The hitbox area
	 * @since 0.1.0
	 */
	public @NotNull Area getArea() {
		return hitbox;
	}
	
	/**
	 * Creates an {@link Area} from the image based on the locations that match and doesn't match the specified color.
	 *
	 * @param target The target color
	 * @param bi     The image
	 * @return The created area
	 * @since 0.1.0
	 */
	public @NotNull Area createOutline(@NotNull Color target, @NotNull BufferedImage bi) {
		GeneralPath gp = new GeneralPath();
		
		boolean cont = false;
		int targetRGB = target.getRGB();
		for(int xx = 0; xx < bi.getWidth(); xx++) {
			for(int yy = 0; yy < bi.getHeight(); yy++) {
				if(bi.getRGB(xx, yy) == targetRGB) {
					if(cont) {
						gp.lineTo(xx, yy);
						gp.lineTo(xx, yy + 1);
						gp.lineTo(xx + 1, yy + 1);
						gp.lineTo(xx + 1, yy);
						gp.lineTo(xx, yy);
					} else {
						gp.moveTo(xx, yy);
					}
					cont = true;
				} else {
					cont = false;
				}
			}
			cont = false;
		}
		gp.closePath();
		
		return new Area(gp);
	}
	
	@Override
	public Rectangle getBounds() {
		return hitbox.getBounds();
	}
	
	@Override
	public Rectangle2D getBounds2D() {
		return hitbox.getBounds2D();
	}
	
	@Override
	public boolean contains(double x, double y) {
		return hitbox.contains(x, y);
	}
	
	@Override
	public boolean contains(Point2D p) {
		return hitbox.contains(p);
	}
	
	@Override
	public boolean intersects(double x, double y, double w, double h) {
		return hitbox.intersects(x, y, w, h);
	}
	
	@Override
	public boolean intersects(Rectangle2D r) {
		return hitbox.intersects(r);
	}
	
	@Override
	public boolean contains(double x, double y, double w, double h) {
		return hitbox.contains(x, y, w, h);
	}
	
	@Override
	public boolean contains(Rectangle2D r) {
		return hitbox.contains(r);
	}
	
	@Override
	public PathIterator getPathIterator(AffineTransform at) {
		return hitbox.getPathIterator(at);
	}
	
	@Override
	public PathIterator getPathIterator(AffineTransform at, double flatness) {
		return hitbox.getPathIterator(at, flatness);
	}
	
	/**
	 * Functional interface for executing actions on image hitboxes.
	 *
	 * @since 0.1.0
	 */
	@FunctionalInterface
	public static interface HitboxCreatedRunnable {
		/**
		 * Runs whenever the hitbox is created.
		 *
		 * @param hitbox The created hitbox
		 * @since 0.1.0
		 */
		public void whenFinished(@NotNull ImageHitbox hitbox);
	}
}
